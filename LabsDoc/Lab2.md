## Lab2 : System Calls



### 1. trace (M)



意思就是说， 需要完成一个系统调用 `trace` 对调用进行追踪，使用方法 `trace bit-mask ...` 



```tex
if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value;
```





```shell
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
```





跟着 `hint` 做了一些， 但是还是没有搞明白进行系统调用的时候具体发生了什么事情， 争取自己独立完成实验，不要看别人的博客。



在进行系统调用的时候， 会把系统调用号放到 `a7` 寄存器中

在 `syscall.h`  中， 对每一个系统调用分配了编号

```c
// System call numbers
#define SYS_fork    1
#define SYS_exit    2
#define SYS_wait    3
#define SYS_pipe    4
...
```



由 `usys.pl` 自动生成的 `user/usys.S` 文件

```assembly
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
.global exit
```



`kernel/syscall.c` 中的 `syscall` 函数如下, 把调用号从 `a7` 中取出， 返回值放入到 `a0` 中

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();
  
  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```



进行系统调用的时候， 会产生**中断**，  由 **系统调用** 产生的中断称为 $trap$ 



`syscall.c` 中的 `syscalls` 是一个函数指针数组, 例如在调用 `wait(0)` 的时候， 会把 `wait` 对应的编号放到 `a7` 中， 然后调用 `sys_wait` 函数

```c
// syscalls[] is a function pointer array
static uint64 (*syscalls[])(void) = {
[SYS_fork]    sys_fork,
[SYS_exit]    sys_exit,
[SYS_wait]    sys_wait,
[SYS_pipe]    sys_pipe,
[SYS_read]    sys_read,
...
```



观察 `user/trace.c`  , 

```c
int
main(int argc, char *argv[])
{
  int i;
  char *nargv[MAXARG];

  if(argc < 3 || (argv[1][0] < '0' || argv[1][0] > '9')){
    fprintf(2, "Usage: %s mask command\n", argv[0]);
    exit(1);
  }

  if (trace(atoi(argv[1])) < 0) {
    fprintf(2, "%s: trace failed\n", argv[0]);
    exit(1);
  }
  
  for(i = 2; i < argc && i < MAXARG; i++){
    nargv[i-2] = argv[i];
  }
  exec(nargv[0], nargv);
  exit(0);
}
```



第一次实验的结果

```sh
make: 'kernel/kernel' is up to date.
== Test trace 32 grep == trace 32 grep: OK (1.2s) 
    (Old xv6.out.trace_32_grep failure log removed)
== Test trace all grep == trace all grep: FAIL (1.2s) 
    ...
         3: syscall read -> 966
         3: syscall read -> 70
         3: syscall read -> 0
         3: syscall close -> 0
         $ qemu-system-riscv64: terminating on signal 15 from pid 4100401 (make)
    MISSING '^\d+: syscall trace -> 0'
    QEMU output saved to xv6.out.trace_all_grep
== Test trace nothing == trace nothing: OK (1.0s) 
== Test trace children == trace children: OK (16.8s) 
    (Old xv6.out.trace_children failure log removed)
```

调查了一番， 是忘记了 `trace`  自己， 修改过后成功通过

![image-20210929210859706](https://img-bucket-zhl.oss-cn-shanghai.aliyuncs.com/image-20210929210859706.png)



`sysproc.c` 中的 `sys_trace` 函数

```c
uint64
sys_trace(void)
{
    int mask;
    if(argint(0, &mask) < 0)
      return -1;
    
    myproc()->mask = mask;
    if((mask >> SYS_trace) & 1){
      printf("%d: syscall trace -> 0\n", myproc()->pid);
    }
    return 0;
}
```

`syscall.c` 中的 `syscall` 函数

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  //print trace info
  int mask = p->mask;

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();

    if( (mask >> num) & 1){
      printf("%d: syscall %s -> %d\n", myproc()->pid, syscall_names[num], p->trapframe->a0);
    }

  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```



### 2. sysinfo (M)

需要完成一个系统调用 `sysinfo` , 要实现的事情是获取信息到 `struct sysinfo` 中

```c
struct sysinfo {
  uint64 freemem;   // amount of free memory (bytes)
  uint64 nproc;     // number of process
};
```

需要在 `kernel/kalloc.c` 中实现获取 `freemem` 的函数

在 `kernel/proc.c` 中实现获取 `nproc` 的函数



有一个调用 `copyout` ,  从 `kernel` 空间拷贝数据到 `user` 空间

```c
// Copy from kernel to user.
// Copy len bytes from src to virtual address dstva in a given page table.
// Return 0 on success, -1 on error.
int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
{
  ...
}
```



所以在 `sysproc.c` 中 `sys_sysinfo` 的基本实现如下

```c
uint64
sys_sysinfo(void)
{
    info.freemem = freemem();
    info.nproc = nproc();

    uint64 addr;
    if(argaddr(0, &addr) < 0){
      return -1;
    }
    if(copyout(myproc()->pagetable, addr, (char*)&info, sizeof(info)) < 0)
      return -1;
    return 0;
}
```



下面考虑， `freemen()` 和 `nproc()` 的实现



`kalloc.c` 中管理空闲内存的方式是使用一个空闲链表，每一个节点都表示一个空闲的 `page` 



```c
struct run {
  struct run *next;
};

struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;
```



所以为了获取空间内存， 可以遍历整个链表， 计算长度即可， 记得乘上 `PGSIZE` 

```c
uint64
freemem(void)
{
  // for lab2 sysinfo
  // get number of bytes of free memory
  volatile uint64 count = 0;
  acquire(&kmem.lock);
  struct run* head = kmem.freelist;
  while(head){
    count++;
    head = head->next;
  }
  release(&kmem.lock);
  //printf("%d\n", count);
  return count * PGSIZE;
}
```



对于 `nproc` ， 遍历所有的进程，对状态不是 `UNUSED` 的进程进行计数

```c
uint64
nproc(void)
{
  uint64 count = 0;
  struct proc *p;

  for(p = proc; p < &proc[NPROC]; p++) {
    acquire(&p->lock);
    if(p->state != UNUSED) {
      count++;
    }
    release(&p->lock);
  }
  return count;
}
```



这次的实验不是特别难， 没有看其资料，独立完成的， 体验还是不错， 对一些概念也有了更深入一些的体验



![image-20211001101259669](https://img-bucket-zhl.oss-cn-shanghai.aliyuncs.com/image-20211001101259669.png)
